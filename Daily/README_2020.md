# Daily

## Notice

> 这是一个有梦想的人在他即将大三立下的一个FLAG
>
> 计划在未来的**每一天**打卡**codeWars**或者**LeetCode**
>
> 欢迎大家监督：）我会会会加油的！

**CodeWars**

* 这是一个分语言的刷题网站，好处是可以借鉴不同语言的优秀解答
* 这个有梦想的人决定在这个网站巩固语法，养成良好的代码习惯
* 他说他会更新 `C` `C++` `Java` `Python` `JavaScript`

**LeetCode**

* 这是一个偏重于算法思维的刷题网站，唯一的缺点是C/C++不能混用
* 这个有梦想的人决定在这个网站恶补算法，为面试做好准备
* 由于解题时间可能过长，这个人决定每次随机选择一种语言求解
* ~~根据他的习惯一般还是`C` `C++`~~
* 最后他基本用`Java`

```
{\ _ /}
(* . *)
 >I加油I
```

## Update Log

### 2020.1

| Date  | Title-Link                                                   | Method          | Describe                                                     | TODO        |
| ----- | ------------------------------------------------------------ | --------------- | ------------------------------------------------------------ | ----------- |
| 01.01 | [18. 4Sum](LeetCode/202001/20200101.md)                      | `Array`         | 给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。 |             |
| 01.02 | [31. Next Permutation](LeetCode/202001/20200102.md)          | `Array`         | 实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。 | review      |
| 01.03 | [39. Combination Sum](LeetCode/202001/20200103.md)           | `Array`         | 给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 |             |
| 01.04 | [40. Combination Sum II](LeetCode/202001/20200104.md)        | `Array`         | 给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。candidates 中的每个数字在每个组合中只能使用一次。 |             |
| 01.05 | [48. Rotate Image](LeetCode/202001/20200105.md)              | `Matrix`        | 给定一个 n × n 的二维矩阵表示一个图像。需要原地旋转          | review      |
| 01.06 | [376. Wiggle Subsequence](LeetCode/202001/20200106.md)       | `DP`            | 给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。 |             |
| 01.07 | [1277. Count Square Submatrices with All Ones](LeetCode/202001/20200107.md) | `DP`            | 给你一个 `m * n` 的矩阵，矩阵中的元素不是 `0` 就是 `1`，请你统计并返回其中完全由 `1` 组成的 **正方形** 子矩阵的个数。 |             |
| 01.08 | [55. Jump Game](LeetCode/202001/20200108.md)                 | `DP`            | 给定一个非负整数数组，你最初位于数组的第一个位置             |             |
| 01.09 | [66. Plus One](LeetCode/202001/20200109.md)                  | `Array`         | 给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 |             |
| 01.10 | [337. House Robber III](LeetCode/202001/20200110.md)         | `树形DP`        | 在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。 | review      |
| 01.11 | [416. Partition Equal Subset Sum](LeetCode/202001/20200111.md) | `01背包`        | 给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 | 01背包变形  |
| 01.12 | [474. Ones and Zeroes](LeetCode/202001/20200112.md)          | `01背包`        | 你的任务是使用给定的 m 个 0 和 n 个 1 ，找到能拼出存在于数组中的字符串的最大数量。每个 0 和 1 至多被使用一次。 | 01背包变形  |
| 01.13 | [494. Target Sum](LeetCode/202001/20200113.md)               | `DP`            | 给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。返回可以使最终数组和为目标数 S 的所有添加符号的方法数。 | 01背包变形  |
| 01.14 | [523. Continuous Subarray Sum](LeetCode/202001/20200114.md)  | `DP`            | 给定一个包含非负数的数组和一个目标整数 k，编写一个函数来判断该数组是否含有连续的子数组，其大小至少为 2，总和为 k 的倍数，即总和为 n*k，其中 n 也是一个整数。 | hashMap解法 |
| 01.15 | [576. Out of Boundary Paths](LeetCode/202001/20200115.md)    | `DP`            | 给定一个 m × n 的网格和一个球。球的起始坐标为 (i,j) ，你可以将球移到相邻的单元格内，或者往上、下、左、右四个方向上移动使球穿过网格边界。但是，你最多可以移动 N 次。找出可以将球移出边界的路径数量。答案可能非常大，返回 结果 mod 1e9 + 7 的值。 | review      |
| 01.16 | [638. Shopping Offers](LeetCode/202001/20200116.md)          | `DFS`           | 现给定每个物品的价格，每个大礼包包含物品的清单，以及待购物品清单。请输出确切完成待购清单的最低花费。每个大礼包的由一个数组中的一组数据描述，最后一个数字代表大礼包的价格，其他数字分别表示内含的其他种类物品的数量。 |             |
| 01.17 | [646. Maximum Length of Pair Chain](LeetCode/202001/20200117.md) | `贪心`          | 给定一个对数集合，找出能够形成的最长数对链的长度。你不需要用到所有的数对，你可以以任何顺序选择其中的一些数对来构造 |             |
| 01.18 | [646. Maximum Length of Pair Chain](LeetCode/202001/20200118.md) | `DP`            | 给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。 |             |
| 01.19 | [650.  Keys Keyboard](LeetCode/202001/20200119.md)           | `DP` `Math`     | 给定一个数字 n 。你需要使用最少的操作次数，在记事本中打印出恰好 n 个 'A'。输出能够打印出 n 个 'A' 的最少操作次数。 | `review`    |
| 01.20 | [112. Path Sum](LeetCode/202001/20200120.md)                 | `DFS`           | 给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。 |             |
| 01.21 | [189. Rotate Array](LeetCode/202001/20200121.md)             | `Array`         | 给定一个数组，将数组中的元素向右移动 *k* 个位置，其中 *k* 是非负数。 |             |
| 01.22 | [73. Set Matrix Zeroes](LeetCode/202001/20200122.md)         | `DFS`           | 给定一个二维网格和一个单词，找出该单词是否存在于网格中。     |             |
| 01.23 | [79. Word Search](LeetCode/202001/20200123.md)               | `Matrix`        | 给定一个 *m* x *n* 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用**[原地](http://baike.baidu.com/item/原地算法)**算法 |             |
| 01.24 | [56. Merge Intervals](LeetCode/202001/20200123.md)           | `Array`         | 给出一个区间的集合，请合并所有重叠的区间。                   |             |
| 01.25 | [80. Remove Duplicates from Sorted Array II](LeetCode/202001/20200125.md) | `Array`         | 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。O(1) | 双指针      |
| 01.26 | [88. Merge Sorted Array](LeetCode/202001/20200126.md)        | `Array`         | 给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。 |             |
| 01.27 | [90. Subsets II](LeetCode/202001/20200127.md)                | `回溯`          | 给定一个可能包含重复元素的整数数组 ***nums***，返回该数组所有可能的子集（幂集）。 |             |
| 01.28 | [162. Find Peak Element](LeetCode/202001/20200128.md)        | `Binary Search` | 给定一个输入数组 nums，其中 nums[i] ≠ nums[i+1]，找到峰值元素并返回其索引。 |             |
| 01.29 | [111. Minimum Depth of Binary Tree](LeetCode/202001/20200129.md) | `DFS`           | 给定一个二叉树，找出其最小深度。                             |             |
| 01.30 | [257. Binary Tree Paths](LeetCode/202001/20200130.md)        | `DFS`           | 给定一个二叉树，返回所有从根节点到叶子节点的路径。           |             |
| 01.31 | [688. Knight Probability in Chessboard](LeetCode/202001/20200131.md) | `DP`            | 求移动结束后，“马” 仍留在棋盘上的概率。                      |             |

```
{\ _ /}
(* . *)
 >I完成I 1月份共完成31题
```

----



### 2020.2

| Date    | Title-Link                                                   | Method                   | Describe                                                     | TODO          |
| ------- | ------------------------------------------------------------ | ------------------------ | ------------------------------------------------------------ | ------------- |
| 02.01   | [167. Two Sum II - Input array is sorted](LeetCode/202002/20200201.md) | `二分查找`               | 给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。 |               |
| 02.02   | [107. Binary Tree Level Order Traversal II](LeetCode/202002/20200202.md) | `BFS`                    | 给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历） |               |
| 02.03   | [209. Minimum Size Subarray Sum](LeetCode/202002/20200203.md) | `BS` `Two pointer`       | 给定一个含有 **n** 个正整数的数组和一个正整数 **s ，**找出该数组中满足其和 **≥ s** 的长度最小的连续子数组**。**如果不存在符合条件的连续子数组，返回 0 | 二分/滑动窗口 |
| 02.04   | [240. Search a 2D Matrix II](LeetCode/202002/20200204.md)    | `matrix` `binary search` | 编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target | review        |
| 02.05   | [287. Find the Duplicate Number](LeetCode/202002/20200205.md) | `List`                   | 给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。 | 链表寻环      |
| 02.06   | [698. Partition to K Equal Sum Subsets](LeetCode/202002/20200206.md) | `回溯`                   | 给定一个整数数组 `nums` 和一个正整数 `k`，找出是否有可能把这个数组分成 `k` 个非空子集，其总和都相等。 | 经典回溯      |
| 02.07   | [718. Maximum Length of Repeated Subarray](LeetCode/202002/20200207.md) | `DP`                     | 给两个整数数组 `A` 和 `B` ，返回两个数组中公共的、长度最长的子数组的长度。 |               |
| 02.08   | [740. Delete and Earn](LeetCode/202002/20200208.md)          | `DP`                     | 给定一个整数数组 nums ，你可以对它进行一些操作。每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除每个等于 nums[i] - 1 或 nums[i] + 1 的元素。开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。 |               |
| 02.09   | [5. Longest Palindromic Substring](LeetCode/202002/20200209.md) | `DP`                     | 给定一个字符串 `s`，找到 `s` 中最长的回文子串。你可以假设 `s` 的最大长度为 1000。 | review        |
| 02.10   | [32. Longest Valid Parentheses](LeetCode/202002/20200210.md) | `DP`                     | 给定一个只包含 `'('` 和 `')'` 的字符串，找出最长的包含有效括号的子串的长度。 | review        |
| 02.11-1 | [8.二叉树的下一个结点](剑指Offer/8-12/8.二叉树的下一个结点.md) | `Tree`                   | 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 | review        |
| 02.11-2 | [9. 用两个栈实现队列](剑指Offer/8-12/9.用两个栈实现队列.md)  | `Queue` `Stack`          | 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 |               |
| 02.11-3 | [10. 斐波那契数列](剑指Offer/8-12/10.斐波那契数列.md)        | `DP`                     | 大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。 |               |
| 02.11-4 | [11. 旋转数组的最小数字](剑指Offer/8-12/11.旋转数组的最小数字.md) | `Array` `Search`         | 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 |               |
| 02.11-5 | [12.矩阵中的路径](剑指Offer/8-12/12.矩阵中的路径.md)         | `DFS`                    | 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径 |               |
| 02.12-1 | [13.机器人的运动范围](剑指Offer/13-18/13.机器人的运动范围.md) | `DFS`                    | 地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？ |               |
| 02.12-2 | [14. 剪绳子](剑指Offer/13-18/14.剪绳子.md)                   | `DP` `贪心`              | 给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n>1并且m>1），每段绳子的长度记为k[0],k[1],...,k[m]。请问k[0]xk[1]x...xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。 | review        |
| 02.12-3 | [15.二进制中1的个数](剑指Offer/13-18/15.二进制中1的个数.md)  | `Bit`                    | 输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 |               |
| 02.12-4 | [16. 数值的整数次方](剑指Offer/13-18/16.数值的整数次方.md)   | `快速幂`                 | 给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 |               |
| 02.12-5 | [17.打印从1到最大的n位数](剑指Offer/13-18/17.打印从1到最大的n位数.md) | `Array`                  | 输入数字 `n`，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。 |               |
| 02.12-6 | [18.删除链表的节点](剑指Offer/13-18/18.删除链表的节点.md)    | `List`                   | 给定单向链表的头指针和一个要删除的节点的值，定义一个函数在 *O*(1) 时间内删除该节点。 |               |
| 02.13   | [19.正则表达式匹配](剑指Offer/19-23/19.正则表达式匹配.md)    | `DP` `递归`              | 请实现一个函数用来匹配包含'. '和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa"与模式"a.a"和"ab*ac*a"匹配，但与"aa.a"和"ab*a"均不匹配。 | review        |
| 02.13   | [20.表示数值的字符串](剑指Offer/19-23/20.表示数值的字符串.md) | `String`                 | 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。 | review        |
| 02.13   | [21.整数组顺序使奇数位于偶数前面](剑指Offer/19-23/21.调整数组顺序使奇数位于偶数前面.md) | `two points`             | 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。 |               |
| 02.13   | [22.链表中倒数第k个节点](剑指Offer/19-23/22.链表中倒数第k个节点.md) | `快慢指针`               | 输入一个链表，输出该链表中倒数第k个节点。                    |               |
| 02.13   | [23.链表中环的入口结点](剑指Offer/19-23/23.链表中环的入口结点.md) | `List`                   | 给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。 |               |
| 02.14   | [24.反转链表](剑指Offer/24-28/24.反转链表.md)                | `List`                   | 定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。 |               |
| 02.14   | [25.合并两个排序的链表](剑指Offer/24-28/25.合并两个排序的链表.md) | `List`                   | 输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。 | 递归解法      |
| 02.14   | [26.树的子结构](剑指Offer/24-28/26.树的子结构.md)            | `Tree`                   | 输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构) |               |
| 02.14   | [27.二叉树的镜像](剑指Offer/24-28/27.二叉树的镜像.md)        | `tree`                   | 请完成一个函数，输入一个二叉树，该函数输出它的镜像。         |               |
| 02.14   | [28.对称的二叉树](剑指Offer/24-28/28.对称的二叉树.md)        | `Tree`                   | 请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。 |               |
| 02.15   | [29.顺时针打印矩阵](剑指Offer/29-33/29.顺时针打印矩阵.md)    |                          | 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。 |               |
| 02.15   | [30.包含min函数的栈](剑指Offer/29-33/30.包含min函数的栈.md)  | `Stack`                  | 定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。 | review        |
| 02.15   | [31.栈的压入弹出序列](剑指Offer/29-33/31.栈的压入弹出序列.md) | `Stack`                  | 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。 | 队列模拟      |
| 02.15   | [32-I.从上到下打印二叉树](剑指Offer/29-33/32-I.从上到下打印二叉树.md) | `BFS` `Tree`             | 从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。 |               |
| 02.15   | [32-II.从上到下打印二叉树](剑指Offer/29-33/32-II.从上到下打印二叉树.md) | `Tree` `bfs`             | 从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。 |               |
| 02.15   | [32-III.从上到下打印二叉树](剑指Offer/29-33/32-III.从上到下打印二叉树.md) | `BFS` `Tree`             | 请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。 |               |
| 02.15   | [33. 二叉搜索树的后序遍历序列](剑指Offer/29-33/33. 二叉搜索树的后序遍历序列.md) | `BST`                    | 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 `true`，否则返回 `false`。假设输入的数组的任意两个数字都互不相同。 |               |
|         |                                                              |                          |                                                              |               |
|         |                                                              |                          |                                                              |               |
|         |                                                              |                          |                                                              |               |
|         |                                                              |                          |                                                              |               |
|         |                                                              |                          |                                                              |               |
|         |                                                              |                          |                                                              |               |
|         |                                                              |                          |                                                              |               |
|         |                                                              |                          |                                                              |               |
|         |                                                              |                          |                                                              |               |
|         |                                                              |                          |                                                              |               |
|         |                                                              |                          |                                                              |               |
|         |                                                              |                          |                                                              |               |
|         |                                                              |                          |                                                              |               |
|         |                                                              |                          |                                                              |               |
|         |                                                              |                          |                                                              |               |
|         |                                                              |                          |                                                              |               |
|         |                                                              |                          |                                                              |               |
|         |                                                              |                          |                                                              |               |
|         |                                                              |                          |                                                              |               |
|         |                                                              |                          |                                                              |               |
|         |                                                              |                          |                                                              |               |



