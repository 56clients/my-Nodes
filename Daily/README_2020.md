# Daily

## Notice

> 这是一个有梦想的人在他即将大三立下的一个FLAG
>
> 计划在未来的**每一天**打卡**codeWars**或者**LeetCode**
>
> 欢迎大家监督：）我会会会加油的！

**CodeWars**

* 这是一个分语言的刷题网站，好处是可以借鉴不同语言的优秀解答
* 这个有梦想的人决定在这个网站巩固语法，养成良好的代码习惯
* 他说他会更新 `C` `C++` `Java` `Python` `JavaScript`

**LeetCode**

* 这是一个偏重于算法思维的刷题网站，唯一的缺点是C/C++不能混用
* 这个有梦想的人决定在这个网站恶补算法，为面试做好准备
* 由于解题时间可能过长，这个人决定每次随机选择一种语言求解
* ~~根据他的习惯一般还是`C` `C++`~~
* 最后他基本用`Java`

```
{\ _ /}
(* . *)
 >I加油I
```

## Update Log

### 2020.1

| Date  | Title-Link                                                   | Method          | Describe                                                     | TODO        |
| ----- | ------------------------------------------------------------ | --------------- | ------------------------------------------------------------ | ----------- |
| 01.01 | [18. 4Sum](LeetCode/202001/20200101.md)                      | `Array`         | 给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。 |             |
| 01.02 | [31. Next Permutation](LeetCode/202001/20200102.md)          | `Array`         | 实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。 | review      |
| 01.03 | [39. Combination Sum](LeetCode/202001/20200103.md)           | `Array`         | 给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 |             |
| 01.04 | [40. Combination Sum II](LeetCode/202001/20200104.md)        | `Array`         | 给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。candidates 中的每个数字在每个组合中只能使用一次。 |             |
| 01.05 | [48. Rotate Image](LeetCode/202001/20200105.md)              | `Matrix`        | 给定一个 n × n 的二维矩阵表示一个图像。需要原地旋转          | review      |
| 01.06 | [376. Wiggle Subsequence](LeetCode/202001/20200106.md)       | `DP`            | 给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。 |             |
| 01.07 | [1277. Count Square Submatrices with All Ones](LeetCode/202001/20200107.md) | `DP`            | 给你一个 `m * n` 的矩阵，矩阵中的元素不是 `0` 就是 `1`，请你统计并返回其中完全由 `1` 组成的 **正方形** 子矩阵的个数。 |             |
| 01.08 | [55. Jump Game](LeetCode/202001/20200108.md)                 | `DP`            | 给定一个非负整数数组，你最初位于数组的第一个位置             |             |
| 01.09 | [66. Plus One](LeetCode/202001/20200109.md)                  | `Array`         | 给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 |             |
| 01.10 | [337. House Robber III](LeetCode/202001/20200110.md)         | `树形DP`        | 在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。 | review      |
| 01.11 | [416. Partition Equal Subset Sum](LeetCode/202001/20200111.md) | `01背包`        | 给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 | 01背包变形  |
| 01.12 | [474. Ones and Zeroes](LeetCode/202001/20200112.md)          | `01背包`        | 你的任务是使用给定的 m 个 0 和 n 个 1 ，找到能拼出存在于数组中的字符串的最大数量。每个 0 和 1 至多被使用一次。 | 01背包变形  |
| 01.13 | [494. Target Sum](LeetCode/202001/20200113.md)               | `DP`            | 给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。返回可以使最终数组和为目标数 S 的所有添加符号的方法数。 | 01背包变形  |
| 01.14 | [523. Continuous Subarray Sum](LeetCode/202001/20200114.md)  | `DP`            | 给定一个包含非负数的数组和一个目标整数 k，编写一个函数来判断该数组是否含有连续的子数组，其大小至少为 2，总和为 k 的倍数，即总和为 n*k，其中 n 也是一个整数。 | hashMap解法 |
| 01.15 | [576. Out of Boundary Paths](LeetCode/202001/20200115.md)    | `DP`            | 给定一个 m × n 的网格和一个球。球的起始坐标为 (i,j) ，你可以将球移到相邻的单元格内，或者往上、下、左、右四个方向上移动使球穿过网格边界。但是，你最多可以移动 N 次。找出可以将球移出边界的路径数量。答案可能非常大，返回 结果 mod 1e9 + 7 的值。 | review      |
| 01.16 | [638. Shopping Offers](LeetCode/202001/20200116.md)          | `DFS`           | 现给定每个物品的价格，每个大礼包包含物品的清单，以及待购物品清单。请输出确切完成待购清单的最低花费。每个大礼包的由一个数组中的一组数据描述，最后一个数字代表大礼包的价格，其他数字分别表示内含的其他种类物品的数量。 |             |
| 01.17 | [646. Maximum Length of Pair Chain](LeetCode/202001/20200117.md) | `贪心`          | 给定一个对数集合，找出能够形成的最长数对链的长度。你不需要用到所有的数对，你可以以任何顺序选择其中的一些数对来构造 |             |
| 01.18 | [646. Maximum Length of Pair Chain](LeetCode/202001/20200118.md) | `DP`            | 给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。 |             |
| 01.19 | [650.  Keys Keyboard](LeetCode/202001/20200119.md)           | `DP` `Math`     | 给定一个数字 n 。你需要使用最少的操作次数，在记事本中打印出恰好 n 个 'A'。输出能够打印出 n 个 'A' 的最少操作次数。 | `review`    |
| 01.20 | [112. Path Sum](LeetCode/202001/20200120.md)                 | `DFS`           | 给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。 |             |
| 01.21 | [189. Rotate Array](LeetCode/202001/20200121.md)             | `Array`         | 给定一个数组，将数组中的元素向右移动 *k* 个位置，其中 *k* 是非负数。 |             |
| 01.22 | [73. Set Matrix Zeroes](LeetCode/202001/20200122.md)         | `DFS`           | 给定一个二维网格和一个单词，找出该单词是否存在于网格中。     |             |
| 01.23 | [79. Word Search](LeetCode/202001/20200123.md)               | `Matrix`        | 给定一个 *m* x *n* 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用**[原地](http://baike.baidu.com/item/原地算法)**算法 |             |
| 01.24 | [56. Merge Intervals](LeetCode/202001/20200123.md)           | `Array`         | 给出一个区间的集合，请合并所有重叠的区间。                   |             |
| 01.25 | [80. Remove Duplicates from Sorted Array II](LeetCode/202001/20200125.md) | `Array`         | 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。O(1) | 双指针      |
| 01.26 | [88. Merge Sorted Array](LeetCode/202001/20200126.md)        | `Array`         | 给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。 |             |
| 01.27 | [90. Subsets II](LeetCode/202001/20200127.md)                | `回溯`          | 给定一个可能包含重复元素的整数数组 ***nums***，返回该数组所有可能的子集（幂集）。 |             |
| 01.28 | [162. Find Peak Element](LeetCode/202001/20200128.md)        | `Binary Search` | 给定一个输入数组 nums，其中 nums[i] ≠ nums[i+1]，找到峰值元素并返回其索引。 |             |
| 01.29 | [111. Minimum Depth of Binary Tree](LeetCode/202001/20200129.md) | `DFS`           | 给定一个二叉树，找出其最小深度。                             |             |
| 01.30 | [257. Binary Tree Paths](LeetCode/202001/20200130.md)        | `DFS`           | 给定一个二叉树，返回所有从根节点到叶子节点的路径。           |             |
| 01.31 | [688. Knight Probability in Chessboard](LeetCode/202001/20200131.md) | `DP`            | 求移动结束后，“马” 仍留在棋盘上的概率。                      |             |

```
{\ _ /}
(* . *)
 >I完成I 1月份共完成31题
```

----



### 2020.2

| Date    | Title-Link                                                   | Method                   | Describe                                                     | TODO          |
| ------- | ------------------------------------------------------------ | ------------------------ | ------------------------------------------------------------ | ------------- |
| 02.01   | [167. Two Sum II - Input array is sorted](LeetCode/202002/20200201.md) | `二分查找`               | 给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。 |               |
| 02.02   | [107. Binary Tree Level Order Traversal II](LeetCode/202002/20200202.md) | `BFS`                    | 给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历） |               |
| 02.03   | [209. Minimum Size Subarray Sum](LeetCode/202002/20200203.md) | `BS` `Two pointer`       | 给定一个含有 **n** 个正整数的数组和一个正整数 **s ，**找出该数组中满足其和 **≥ s** 的长度最小的连续子数组**。**如果不存在符合条件的连续子数组，返回 0 | 二分/滑动窗口 |
| 02.04   | [240. Search a 2D Matrix II](LeetCode/202002/20200204.md)    | `matrix` `binary search` | 编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target | review        |
| 02.05   | [287. Find the Duplicate Number](LeetCode/202002/20200205.md) | `List`                   | 给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。 | 链表寻环      |
| 02.06   | [698. Partition to K Equal Sum Subsets](LeetCode/202002/20200206.md) | `回溯`                   | 给定一个整数数组 `nums` 和一个正整数 `k`，找出是否有可能把这个数组分成 `k` 个非空子集，其总和都相等。 | 经典回溯      |
| 02.07   | [718. Maximum Length of Repeated Subarray](LeetCode/202002/20200207.md) | `DP`                     | 给两个整数数组 `A` 和 `B` ，返回两个数组中公共的、长度最长的子数组的长度。 |               |
| 02.08   | [740. Delete and Earn](LeetCode/202002/20200208.md)          | `DP`                     | 给定一个整数数组 nums ，你可以对它进行一些操作。每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除每个等于 nums[i] - 1 或 nums[i] + 1 的元素。开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。 |               |
| 02.09   | [5. Longest Palindromic Substring](LeetCode/202002/20200209.md) | `DP`                     | 给定一个字符串 `s`，找到 `s` 中最长的回文子串。你可以假设 `s` 的最大长度为 1000。 | review        |
| 02.10   | [32. Longest Valid Parentheses](LeetCode/202002/20200210.md) | `DP`                     | 给定一个只包含 `'('` 和 `')'` 的字符串，找出最长的包含有效括号的子串的长度。 | review        |
| 02.11-1 | [8.二叉树的下一个结点](剑指Offer/8-12/8.二叉树的下一个结点.md) | `Tree`                   | 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 | review        |
| 02.11-2 | [9. 用两个栈实现队列](剑指Offer/8-12/9.用两个栈实现队列.md) | `Queue` `Stack`          | 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 |               |
| 02.11-3 | [10. 斐波那契数列](剑指Offer/8-12/10.斐波那契数列.md)       | `DP`                     | 大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。 |               |
| 02.11-4 | [11. 旋转数组的最小数字](剑指Offer/8-12/11.旋转数组的最小数字.md) | `Array` `Search`         | 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 |               |
| 02.11-5 | [12.矩阵中的路径](剑指Offer/8-12/12.矩阵中的路径.md)         | `DFS`                    | 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径 |               |
|         |                                                              |                          |                                                              |               |
|         |                                                              |                          |                                                              |               |
|         |                                                              |                          |                                                              |               |
|         |                                                              |                          |                                                              |               |
|         |                                                              |                          |                                                              |               |
|         |                                                              |                          |                                                              |               |
|         |                                                              |                          |                                                              |               |
|         |                                                              |                          |                                                              |               |
|         |                                                              |                          |                                                              |               |
|         |                                                              |                          |                                                              |               |
|         |                                                              |                          |                                                              |               |
|         |                                                              |                          |                                                              |               |
|         |                                                              |                          |                                                              |               |
|         |                                                              |                          |                                                              |               |

