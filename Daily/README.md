# Daily

## Notice
> 这是一个有梦想的人在他即将大三立下的一个FLAG
> 
> 计划在未来的**每一天**打卡**codeWars**或者**LeetCode**
>
> 欢迎大家监督：）我会会会加油的！

**CodeWars**
* 这是一个分语言的刷题网站，好处是可以借鉴不同语言的优秀解答
* 这个有梦想的人决定在这个网站巩固语法，养成良好的代码习惯
* 他说他会更新 `C` `C++` `Java` `Python` `JavaScript`

**LeetCode**
* 这是一个偏重于算法思维的刷题网站，唯一的缺点是C/C++不能混用
* 这个有梦想的人决定在这个网站恶补算法，为面试做好准备
* 由于解题时间可能过长，这个人决定每次随机选择一种语言求解
* ~~根据他的习惯一般还是`C` `C++`~~
* 最后他基本用`Java`
```
{\ _ /}
(* . *)
 >I加油I
```
## Update Log
### 2019.10

| Date    | Title-Link                                                   | Method       | Describe                                                     | TODO     |
| ------- | ------------------------------------------------------------ | ------------ | ------------------------------------------------------------ | -------- |
| 10.01   | [94. 二叉树的中序遍历](LeetCode/20191001.md)                 | `Tree`       | 中序遍历一棵树                                               | 迭代     |
| 10.02   | [127. Word Ladder](LeetCode/20191002.md)                     | `BFS`        | 给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度 | 双向搜索 |
| 10.03   | [450. Delete Node in a BST](LeetCode/20191003.md)            | `BST`        | 给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。 |          |
| 10.03-2 | [700. Search in a Binary Search Tree](LeetCode/20191003-2.md) | `BST`        | 给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。 |          |
| 10.04-1 | [701. Insert into a Binary Search Tree](LeetCode/20191004-1.md) | `BST`        | 给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 保证原始二叉搜索树中不存在新 值。 |          |
| 10.04-2 | [108. Convert Sorted Array to Binary Search Tree](LeetCode/20191004-2.md) | `二分` `BST` | 将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。 |          |
| 10.05-1 | [104. Maximum Depth of Binary Tree](LeetCode/20191005-1.md)  | `Tree` `DFS` | 给定一个二叉树，找出其最大深度。                             |          |
| 10.05-2 | [130. Surrounded Regions](LeetCode/20191005-2.md)            | `DFS`        | 找到所有被 'X' 围绕的区域，并将这些区域里所有的 'O' 用 'X' 填充 |          |
| 10.06-1 | [133. Clone Graph](LeetCode/20191006-1.md)                   | `DFS` `BFS`  | 给定无向连通图中一个节点的引用，返回该图的深拷贝（克隆）。图中的每个节点都包含它的值 val（Int） 和其邻居的列表（list[Node]）。 | review   |
| 10.06-2 | [102. Binary Tree Level Order Traversal](LeetCode/20191006-2.md) | `BFS` `DFS`  | 给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点） |          |
| 10.06-3 | [199. Binary Tree Right Side View](LeetCode/20191006-3.md)   | `BFS`        | 给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。 |          |
| 10.07   | [207. Course Schedule](LeetCode/20191007.md)                 | `拓扑排序`   | 在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1],给定课程总量以及它们的先决条件，判断是否可能完成所有课程的学习？ |          |
| 10.08   | [210. Course Schedule II](LeetCode/20191008.md)              | `拓扑排序`   | 在[课程表1：拓扑排序](20191007.md) 的基础上需要列举出结果    |          |
| 10.09   | [310. Minimum Height Trees](LeetCode/20191009.md)            | `拓扑排序`   | 给出这样的一个图，写出一个函数找到所有的最小高度树并返回他们的根节点。 |          |
| 10.10   | [34. Find First and Last Position of Element in Sorted Array](LeetCode/20191010.md) | `二分查找`   | 给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。 | 夹逼     |
|         |                                                              |              |                                                              |          |
|         |                                                              |              |                                                              |          |
|         |                                                              |              |                                                              |          |
|         |                                                              |              |                                                              |          |
|         |                                                              |              |                                                              |          |
|         |                                                              |              |                                                              |          |
|         |                                                              |              |                                                              |          |
|         |                                                              |              |                                                              |          |
|         |                                                              |              |                                                              |          |
|         |                                                              |              |                                                              |          |
|         |                                                              |              |                                                              |          |
|         |                                                              |              |                                                              |          |
|         |                                                              |              |                                                              |          |
|         |                                                              |              |                                                              |          |

---



### 2019.11

| Date    | Title-Link                                                   | Method        | Describe                                                     | TODO                       |
| ------- | ------------------------------------------------------------ | ------------- | ------------------------------------------------------------ | -------------------------- |
| 11.01   | [221. Maximal Square](LeetCode/20191101.md)                  | `DP`          | 在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积 |                            |
| 11.02   | [279. Perfect Squares](LeetCode/20191102.md)                 | `DP`          | 给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少 |                            |
| 11.03   | [21. Merge Two Sorted Lists](LeetCode/20191103.md)           | `List`        | 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 |                            |
| 11.04   | [Prim&Kruskal](DataStructure/20191103.md)                    | `Graph`       | 最小生成树                                                   |                            |
| 11.05   | [304. Range Sum Query 2D - Immutable](LeetCode/20191105.md)  | `2DDP`        | 给定一个二维矩阵，计算其子矩形范围内元素的总和，该子矩阵的左上角为 (row1, col1) ，右下角为 (row2, col2)。 |                            |
| 11.06   | [105. Construct Binary Tree from Preorder and Inorder Traversal](LeetCode/20191106.md) | `DFS`         | 根据一棵树的前序遍历与中序遍历构造二叉树。                   | 迭代求解                   |
| 11.07   | [24. Swap Nodes in Pairs](LeetCode/20191107.md)              | `List`        | 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。   |                            |
| 11.08   | [328. Odd Even Linked List](LeetCode/20191108.md)            | `List`        | 给定一个单链表，把所有的奇数节点和偶数节点分别排在一起       |                            |
| 11.09   | [100. Same Tree](LeetCode/20191109.md)                       | `Tree`        | 给定两个二叉树，编写一个函数来检验它们是否相同。如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。 |                            |
| 11.10   | [200. Number of Islands](LeetCode/20191110.md)               | `BFS`         | 给定一个由 '1'（陆地）和 '0'（水）组成的的二维网格，计算岛屿的数量。 | 并查集求解                 |
| 11.11   | [61. Rotate List](LeetCode/20191111.md)                      | `List`        | 给定一个链表，旋转链表，将链表每个节点向右移动 *k* 个位置，其中 *k* 是非负数 |                            |
| 11.12   | [116. Populating Next Right Pointers in Each Node](LeetCode/20191112.md) | `Tree`        | 给定一个**完美二叉树**，其所有叶子节点都在同一层，每个父节点都有两个子节点。填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。 |                            |
| 11.13   | [129. Sum Root to Leaf Numbers](LeetCode/20191113.md)        | `DFS` `TREE`  | 给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。例如，从根到叶子节点路径 1->2->3 代表数字 123。求根到叶子节点生成的所有数字之和 |                            |
| 11.14   | [101. Symmetric Tree](LeetCode/20191114.md)                  | `Tree`        | 给定一个二叉树，检查它是否是镜像对称的                       |                            |
| 11.15   | [309. Best Time to Buy and Sell Stock with Cooldown](LeetCode/20191115.md) | `DP`          | 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。 |                            |
| 11.16-1 | [122. Best Time to Buy and Sell Stock II](LeetCode/20191116.md) | `DP`          | 股票交易问题-交易次数不限                                    |                            |
| 11.16-2 | [123. Best Time to Buy and Sell Stock III](LeetCode/20191116-2.md) | `DP`          | 股票交易问题-最多完成2笔交易                                 |                            |
| 11.16-3 | [123. Best Time to Buy and Sell Stock III](LeetCode/20191116-3.md) | `DP`          | 股票交易问题-最多完成k笔交易                                 |                            |
| 11.17   | [714. Best Time to Buy and Sell Stock with Transaction Fee](LeetCode/20191117.md) | `DP`          | 股票交易问题-含手续费                                        |                            |
| 11.18   | [782. Remove Duplicates from Sorted List II](LeetCode/20191118.md) | `List`        | 给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 *没有重复出现* 的数字。 | bestANS                    |
| 11.19   | [338. Counting Bits](LeetCode/20191119.md)                   | `DP`          | 给定一个非负整数 **num**。对于 **0 ≤ i ≤ num** 范围中的每个数字 **i** ，计算其二进制数中的 1 的数目并将它们作为数组返回。 |                            |
| 11.20   | [86. Partition List](LeetCode/20191120.md)                   | `List`        | 给定一个链表和一个特定值 *x*，对链表进行分隔，使得所有小于 *x* 的节点都在大于或等于 *x* 的节点之前。 |                            |
| 11.21   | [322. Coin Change](LeetCode/20191121.md)                     | `DP`          | 给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。 |                            |
| 11.22   | [83. Remove Duplicates from Sorted List](LeetCode/20191122.md) | `List`        | 给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。 |                            |
| 11.23   | [106. Construct Binary Tree from Inorder and Postorder Traversal](LeetCode/20191123.md) | `Tree`        | 根据一棵树的中序遍历与后序遍历构造二叉树。                   |                            |
| 11.24   | [74. Search a 2D Matrix](LeetCode/20191124.md)               | `二分查找`    | 编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值，矩阵有序。 | 二分查找的特定位置返回分析 |
| 11.25   | [394. Decode String](LeetCode/20191125.md)                   | `DFS`         | 给定一个经过编码的字符串，返回它解码后的字符串。如s = "2[abc]3[cd]ef", 返回 "abcabccdcdcdef". |                            |
| 11.26   | [343. Integer Break](LeetCode/20191126.md)                   | `DP`          | 给定一个正整数 *n*，将其拆分为**至少**两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。 |                            |
| 11.27   | [206. Reverse Linked List](LeetCode/20191127.md)             | `List`        | 反转一个单链表。                                             |                            |
| 11.28   | [103. Binary Tree Zigzag Level Order Traversal](LeetCode/20191128.md) | `BFS` `Stack` | 给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。 |                            |
| 11.29   | [92. Reverse Linked List II](LeetCode/20191129.md)           | `List`        | 反转从位置 *m* 到 *n* 的链表。请使用一趟扫描完成反转         | 递归写法                   |
| 11.30   | [136. Single Number](LeetCode/20191130.md)                   | `Bit`         | 给定一个**非空**整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 |                            |

```
{\ _ /}
(* . *)
 >I完成I 11月份共完成33题
```

---



### 2019.12

| Date    | Title-Link                                                   | Method        | Describe                                                     | TODO             |
| ------- | ------------------------------------------------------------ | ------------- | ------------------------------------------------------------ | ---------------- |
| 12.01   | [191. Number of 1 Bits](LeetCode/201912/20191201.md)         | `Bit`         | 编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。 |                  |
| 12.02-1 | [95. Unique Binary Search Trees II](LeetCode/201912/20191202-1.md) | `BST`         | 给定一个整数 n，生成所有由 1 ... n 为节点所组成的二叉搜索树。 | review           |
| 12.02-2 | [357. Count Numbers with Unique Digits](LeetCode/201912/20191202-2.md) | `DP` `Math`   | 给定一个非负整数 n，计算各位数字都不同的数字 x 的个数，其中 0 ≤ x < 10^n 。 |                  |
| 12.03   | [208. Implement Trie (Prefix Tree)](LeetCode/201912/20191203.md) | `Trie`        | 实现一个 Trie (前缀树)，包含 `insert`, `search`, 和 `startsWith` 这三个操作。 | 前缀树基础       |
| 12.04   | [222. Count Complete Tree Nodes](LeetCode/201912/20191204.md) | `CBT`         | 给出一个**完全二叉树**，求出该树的节点个数。                 |                  |
| 12.05   | [211. Add and Search Word - Data structure design](LeetCode/201912/20191205.md) | `Trie` `BFS`  | search(word) 可以搜索文字或正则表达式字符串，字符串只包含字母 . 或 a-z 。 . 可以表示任何一个字母。 |                  |
| 12.06   | [69. Sqrt(x)](LeetCode/201912/20191206.md)                   | `二分`        | 实现` int sqrt(int x)` 函数。二分猜数                        |                  |
| 12.07   | [138. Copy List with Random Pointer](LeetCode/201912/20191207.md) | `List`        | 给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。返回链表深拷贝 |                  |
| 12.08   | [143. Reorder List](LeetCode/201912/20191208.md)             | `List`        | 给定一个单链表 L：L0→L1→…→Ln-1→Ln ，<br/>将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→… | 链表总结         |
| 12.09   | [231. Power of Two](LeetCode/201912/20191209.md)             | `Bits`        | 给定一个整数，编写一个函数来判断它是否是 2 的幂次方。        |                  |
| 12.10   | [230. 二叉搜索树中第K小的元素](LeetCode/201912/20191210.md)  | `BST`         | 给定一个二叉搜索树，编写一个函数 `kthSmallest` 来查找其中第 **k** 个最小的元素。 |                  |
| 12.11   | [11. Container With Most Water](LeetCode/201912/20191211.md) | `Two Pointer` | 给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 |                  |
| 12.12   | [15. 3Sum](LeetCode/201912/20191212.md)                      | `Array`       | 给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。注意：答案中不可以包含重复的三元组。 |                  |
| 12.13   | [54. 螺旋矩阵](LeetCode/201912/20191213.md)                  | `Matrix`      | 给定一个包含 *m* x *n* 个元素的矩阵（*m* 行, *n* 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。 |                  |
| 12.14   | [413. Arithmetic Slices](LeetCode/201912/20191214.md)        | `DP`          | 如果一个数列至少有三个元素，并且任意两个相邻元素之差相同，则称该数列为等差数列。函数要返回数组 A 中所有为等差数组的子数组个数。 |                  |
| 12.15   | [377. Combination Sum IV](LeetCode/201912/20191215.md)       | `DP`          | 给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。 | review           |
| 12.16   | [516. Longest Palindromic Subsequence](LeetCode/201912/20191216.md) | `DP`          | 给定一个字符串`s`，找到其中最长的回文子序列。可以假设`s`的最大长度为`1000`。 |                  |
| 12.17   | [515. Find Largest Value in Each Tree Row](LeetCode/201912/20191217.md) | `BFS`         | 您需要在二叉树的每一行中找到最大的值。                       |                  |
| 12.18   | [72. Edit Distance](LeetCode/201912/20191218.md)             | `DP`          | 给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。 | 最短编辑距离     |
|         |                                                              |               |                                                              |                  |
|         |                                                              |               |                                                              |                  |
|         |                                                              |               |                                                              |                  |
| 12.24   | [368. Largest Divisible Subset](LeetCode/201912/20191224.md) | `DP`          | 给出一个由无重复的正整数组成的集合，找出其中最大的整除子集，子集中任意一对 (Si，Sj) 都要满足：Si % Sj = 0 或 Sj % Si = 0。 | **回来了回来了** |
| 12.25   | [26. Remove Duplicates from Sorted Array](LeetCode/201912/20191225.md) | `Array`       | 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 |                  |
| 12.26   | [27. Remove Element](LeetCode/201912/20191226.md)            | `Array`       | 给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。 |                  |
|         |                                                              |               |                                                              |                  |
|         |                                                              |               |                                                              |                  |
|         |                                                              |               |                                                              |                  |
|         |                                                              |               |                                                              |                  |



---


