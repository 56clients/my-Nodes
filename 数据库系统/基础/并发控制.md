# 并发控制

## 事务执行概述

> 允许多个用户同时使用的数据库系统，在同一时刻并发运行的事务数可达数百上千个

### 多事务执行方式

#### 事务串行执行

* 每个时刻只有一个事务运行，其他事务必须等待该事务结束
* **不能充分利用资源 ，发挥数据库共享资源的特点**

![alt](../img/bx-1.png)

#### 交叉并发方式（Interleaved Concurrency）

* **应用于单处理机系统**
* 事务轮流交叉运行
* 由于是单核，并没有真正并行运行，但是能**减少处理机空闲时间**，从而提高系统效率

![alt](../img/bx-2.png)

#### 同时并发方式（simultaneous concurrency）

* **应用于多处理机系统**
* 每个时刻每个处理机运行一个事务，多处理机同时运行多个事务，实现多事务并行



### 事务并发的重要性

#### 事务并发执行带来的问题

* 会产生多个事务**同时存取**同一数据
* 可能**会存取和存储不正确的数据**，破坏事务隔离性和数据库一致性

数据库管理系统必须提供并发控制机制，并发控制机制是衡量一个数据库管理系统性能的重要标志之一



## 并发控制概述

### 基本概念

> **事务是并发控制的基本单位**

#### 并发控制机制的任务

* 对并发操作进行正确调度
* 保证数据库的隔离性和一致性



### 并发导致数据不一致性

### 机票贩卖

* 导致数据库的不一致性
* T2覆盖了T1的修改

![alt](../img/bx-3.png)

#### 记号

* **R(x)** 读数据x
* **W(x)** 写数据x



### 不一致类别

#### 丢失修改(Lost Update)

事务T1和事务T2**同时读入同一数据并修改**，T2的提交破坏了T1的提交结果，导致T1的修改丢失

**简写为：`W(x)W(x)`**

##### 机票贩卖的丢失修改

![alt](../img/bx-4.png)



#### 不可重复读(Non-repeatable Read)

##### 问题

* 事务T1读取数据
* 事务T2执行更新数据
* **导致T1无法再现前一次读取结果**

##### 产生问题

![alt](../img/bx-5.png)

* `R(x)[Update(x)W(x)]`

  * T1读取，T2修改
  * T1再次读取该数据时，得到和前一次不同的值

  ![alt](../img/bx-6.png)

* `R(x)[Delete(x)W(x)]`

  * T1读取，T2删除部分记录
  * T1再次读取发现部分数据丢失

* `R(x)[Insert(x)W(x)]`

  * T1读取，T2插入若干记录
  * T1按相同条件读取，发现多了些记录



#### 读脏数据（Dirty Read)

* 事务T1修改某一数据，将其写回
* 事务T2读取同一数据，T1由于某种原因被撤销
* 此时T1已修改过的数据恢复原值，T2读到的数据就与数据库的数据不一致
* T2读到的数据不正确，即脏数据

**简写为：`W(x)R(x)`**



![alt](../img/bx-7.png)



## 封锁

### 概要

* 事务T在对某个数据对象操作之前，先向系统发送请求，对其加锁
* 加锁后事务T就对该数据对象有一定的控制
* 事务T释放该锁之前，其他事务不能更新此数据对象



### 锁的类型

#### 排他锁（Exclusive Locks，简记为X锁，写锁）

* 事务T对数据对象A加上X锁，则**只允许T读取和修改A**，直到T释放A上的锁
* 

























