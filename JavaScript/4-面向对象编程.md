# 4-面向对象编程

## 创建对象

### 指向机制
当用`obj.xxx`访问某个对象属性是，JS引擎会在当前对象查找该属性，没有找到则往原型对象上找，一直追溯到`Object.prototype`
最后没有找到返回`undefined`
例如一个`Array`对象的原型链
```text
arr ----> Array.prototype ----> Object.prototype ----> null
```
函数对象的原型链
```text
function foo() {
    return 0;
}
```

### 构造函数
> 其实就是普通函数，切用`new`来调用这个函数，会返回一个对象
```javascript 1.8
function Student(name) {
    this.name = name;
    this.hello = function () {
        alert('Hello, ' + this.name + '!');
    }
}

var xiaoming = new Student('小明');
xiaoming.name; // '小明'
xiaoming.hello(); // Hello, 小明!
```

这些对象的原型链
```text
xiaoming ↘
xiaohong -→ Student.prototype ----> Object.prototype ----> null
xiaojun  ↗
```
用`new Student()`创建按对象还从原型上获得一个`constructor`属性，指向`Student`本身
```javascript 1.8
xiaoming.constructor === Student.prototype.constructor; // true
Student.prototype.constructor === Student; // true

Object.getPrototypeOf(xiaoming) === Student.prototype; // true

xiaoming instanceof Student; // true
```

### 共享函数
> 上述的构造方法中，`hello`是new出来的对象各自都具有的一个函数
```javascript 1.8
xiaoming.name; // '小明'
xiaohong.name; // '小红'
xiaoming.hello; // function: Student.hello()
xiaohong.hello; // function: Student.hello()
xiaoming.hello === xiaohong.hello; // false
```
这样会十分占据内存空间，通过将希望公有的函数移动到`xiaoming` ·xiaohong`这些对象的共同原型上就可以实现共享
```javascript 1.8
function Student(name) {
    this.name = name;
}

Student.prototype.hello = function () {
    alert('Hello, ' + this.name + '!');
};
```

### 封装new操作
```javascript 1.8
function Student(props) {
    this.name = props.name || '匿名'; // 默认值为'匿名'
    this.grade = props.grade || 1; // 默认值为1
}

Student.prototype.hello = function () {
    alert('Hello, ' + this.name + '!');
};

function createStudent(props) {
    return new Student(props || {})
}

var xiaoming = createStudent({
    name: '小明'
});

xiaoming.grade; // 1
```